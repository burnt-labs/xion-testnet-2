name: Create Release PR 

on:
  push:
    branches:
      # - main
      # - master
      - feat/do-85-generate-upgrade-proposals-n-release-binaries

  workflow_dispatch: # NOTICE: To trigger the workflow_dispatch event, the workflow must be in the default branch.
    inputs:
      release_tag:
        description: 'Release tag to update the chain registry with'
        required: true
        type: string
      deposit:
        description: 'Deposit amount (default: 1000000000uxion)'
        required: false
        default: '1000000000uxion'
        type: string
      expedited:
        description: 'Expedited proposal'
        required: false
        default: false
        type: boolean

env:
  # API endpoints
  XION_TESTNET_API: "https://api.xion-testnet-2.burnt.com/cosmos/base/tendermint/v1beta1"
  
  # Target branch for PRs (TODO: change to 'main' when ready)
  TARGET_BRANCH: feat/do-85-generate-upgrade-proposals-n-release-binaries
  
  # Input values from workflow_dispatch
  # RELEASE_TAG: ${{ github.event.inputs.release_tag }}
  RELEASE_TAG: v22.0.0 # TODO : delete this
  DEPOSIT: 1000000000uxion
  EXPEDITED: false
  
  # Placeholder values for binary checksums
  PLACEHOLDER_CHECKSUM_DARWIN_AMD64: "--ADD-HERE-YOUR-VALUE--"
  PLACEHOLDER_CHECKSUM_DARWIN_ARM64: "--ADD-HERE-YOUR-VALUE--"
  PLACEHOLDER_CHECKSUM_LINUX_AMD64: "--ADD-HERE-YOUR-VALUE--"
  PLACEHOLDER_CHECKSUM_LINUX_ARM64: "--ADD-HERE-YOUR-VALUE--"

jobs:
  create-release-pr:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Load prompts into environment variables before switching branches  
      run: |
        # Load prompts using base64 to avoid delimiter issues
        CLAUDE_PROMPT_B64=$(cat .github/workflows/prompts/claude-api-prompt.md | base64 -w 0)
        echo "CLAUDE_PROMPT_B64=$CLAUDE_PROMPT_B64" >> $GITHUB_ENV
        
        FALLBACK_PROMPT_B64=$(cat .github/workflows/prompts/fallback-template.md | base64 -w 0)
        echo "FALLBACK_PROMPT_B64=$FALLBACK_PROMPT_B64" >> $GITHUB_ENV

    - name: Prepare branch variables and checkout
      run: |
        # Extract version from RELEASE_TAG and set branch name
        VERSION_NUM=$(echo "${{ env.RELEASE_TAG }}" | sed 's/v\([0-9]*\)\.0\.0/\1/')
        VERSION="v${VERSION_NUM}"
        BRANCH_NAME="release/${{ env.RELEASE_TAG }}"
        
        echo "VERSION=$VERSION" >> $GITHUB_ENV
        echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
        
        # Set up git config
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Fetch all remote branches to ensure we have latest refs
        git fetch origin
        
        # Check if remote branch exists and handle accordingly
        if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
          echo "Remote branch $BRANCH_NAME exists, checking out and pulling latest changes"
          
          # Check if local branch exists
          if git show-ref --verify --quiet refs/heads/"$BRANCH_NAME"; then
            echo "Local branch exists, switching to it"
            git checkout "$BRANCH_NAME"
          else
            echo "Local branch doesn't exist, creating from remote"
            git checkout -b "$BRANCH_NAME" origin/"$BRANCH_NAME"
          fi
          
          # Pull latest changes from remote to avoid conflicts
          git pull origin "$BRANCH_NAME"
          
        else
          echo "Remote branch $BRANCH_NAME doesn't exist, creating new branch"
          git checkout -b "$BRANCH_NAME"
        fi
        
    - name: Calculate block height
      run: |
        # Get current block height and timestamp
        CURRENT_BLOCK=$(curl -s -X 'GET' "${{ env.XION_TESTNET_API }}/blocks/latest" -H 'accept: application/json' | jq -r '.block.header.height')
        CURRENT_TIME=$(curl -s -X 'GET' "${{ env.XION_TESTNET_API }}/blocks/latest" -H 'accept: application/json' | jq -r '.block.header.time')
        
        echo "Current block: $CURRENT_BLOCK"
        echo "Current time: $CURRENT_TIME"
        
        # Get block from 10000 blocks ago
        OLD_BLOCK=$((CURRENT_BLOCK - 10000))
        OLD_BLOCK_INFO=$(curl -s -X 'GET' "${{ env.XION_TESTNET_API }}/blocks/$OLD_BLOCK" -H 'accept: application/json' | jq -r '.block.header.time')
        
        echo "Old block ($OLD_BLOCK) time: $OLD_BLOCK_INFO"
        
        # Calculate average block time (in seconds)
        CURRENT_TIMESTAMP=$(date -d "$CURRENT_TIME" +%s)
        OLD_TIMESTAMP=$(date -d "$OLD_BLOCK_INFO" +%s)
        TIME_DIFF=$((CURRENT_TIMESTAMP - OLD_TIMESTAMP))
        AVERAGE_BLOCK_TIME=$(echo "scale=2; $TIME_DIFF / 10000" | bc)
        
        echo "Average block time: ${AVERAGE_BLOCK_TIME} seconds"
        
        # Calculate blocks for 2 days (172800 seconds)
        BLOCKS_IN_2_DAYS=$(echo "scale=0; 172800 / $AVERAGE_BLOCK_TIME" | bc)
        
        # Calculate target block height (round to nearest 1000)
        TARGET_BLOCKS=$((BLOCKS_IN_2_DAYS + CURRENT_BLOCK))
        ROUNDED_BLOCKS=$(( (TARGET_BLOCKS + 500) / 1000 * 1000 ))
        
        echo "Blocks in 2 days: $BLOCKS_IN_2_DAYS"
        echo "Target block height: $ROUNDED_BLOCKS"
        
        # Set the calculated height as environment variable
        echo "CALCULATED_HEIGHT=$ROUNDED_BLOCKS" >> $GITHUB_ENV

    - name: Fetch release checksums
      run: |
        # Construct the checksums URL for the release
        CHECKSUMS_URL="https://github.com/burnt-labs/xion/releases/download/${{ env.RELEASE_TAG }}/xiond-${{ env.RELEASE_TAG }}-checksums.txt"
        echo "Fetching checksums from: $CHECKSUMS_URL"
        
        # Try to fetch the checksums file
        CHECKSUMS_RESPONSE=$(curl -s -w "%{http_code}" "$CHECKSUMS_URL" -o checksums_temp.txt)
        HTTP_CODE="${CHECKSUMS_RESPONSE: -3}"
        
        if [ "$HTTP_CODE" = "200" ]; then
          echo "âœ… Successfully fetched checksums for ${{ env.RELEASE_TAG }}"
          
          # Parse the checksums file and extract values
          CHECKS_FILE="checksums_temp.txt"
          
          # Extract checksums for different platforms
          DARWIN_AMD64_CHECKSUM=$(grep "darwin_amd64.tar.gz" "$CHECKS_FILE" | awk '{print $1}')
          DARWIN_ARM64_CHECKSUM=$(grep "darwin_arm64.tar.gz" "$CHECKS_FILE" | awk '{print $1}')
          LINUX_AMD64_CHECKSUM=$(grep "linux_amd64.tar.gz" "$CHECKS_FILE" | awk '{print $1}')
          LINUX_ARM64_CHECKSUM=$(grep "linux_arm64.tar.gz" "$CHECKS_FILE" | awk '{print $1}')
          
          # Set environment variables with real checksums
          echo "DARWIN_AMD64_CHECKSUM=$DARWIN_AMD64_CHECKSUM" >> $GITHUB_ENV
          echo "DARWIN_ARM64_CHECKSUM=$DARWIN_ARM64_CHECKSUM" >> $GITHUB_ENV
          echo "LINUX_AMD64_CHECKSUM=$LINUX_AMD64_CHECKSUM" >> $GITHUB_ENV
          echo "LINUX_ARM64_CHECKSUM=$LINUX_ARM64_CHECKSUM" >> $GITHUB_ENV
          
          echo "âœ… Using real checksums:"
          echo "  Darwin AMD64: $DARWIN_AMD64_CHECKSUM"
          echo "  Darwin ARM64: $DARWIN_ARM64_CHECKSUM"
          echo "  Linux AMD64: $LINUX_AMD64_CHECKSUM"
          echo "  Linux ARM64: $LINUX_ARM64_CHECKSUM"
          
        else
          echo "âš ï¸  Checksums file not found for ${{ env.RELEASE_TAG }} (HTTP $HTTP_CODE)"
          if [ "$HTTP_CODE" = "404" ]; then
            echo "ðŸ“ This appears to be a future release - checksums will be available when the release is published"
          fi
          echo "ðŸ“ Using placeholder values for now"
          
          # Set environment variables with placeholder values
          echo "DARWIN_AMD64_CHECKSUM=${{ env.PLACEHOLDER_CHECKSUM_DARWIN_AMD64 }}" >> $GITHUB_ENV
          echo "DARWIN_ARM64_CHECKSUM=${{ env.PLACEHOLDER_CHECKSUM_DARWIN_ARM64 }}" >> $GITHUB_ENV
          echo "LINUX_AMD64_CHECKSUM=${{ env.PLACEHOLDER_CHECKSUM_LINUX_AMD64 }}" >> $GITHUB_ENV
          echo "LINUX_ARM64_CHECKSUM=${{ env.PLACEHOLDER_CHECKSUM_LINUX_ARM64 }}" >> $GITHUB_ENV
          
          echo "ðŸ“ Using placeholder checksums (will be updated when release is available)"
        fi
        
        # Clean up temporary file
        rm -f checksums_temp.txt
  
    - name: Get GitHub comparison data
      run: |
        # Extract version number from release tag
        CURRENT_VERSION="${{ env.RELEASE_TAG }}"
        # Extract major version number and calculate previous version
        CURRENT_MAJOR=$(echo "$CURRENT_VERSION" | sed 's/v\([0-9]*\)\.0\.0/\1/')
        PREVIOUS_MAJOR=$((CURRENT_MAJOR - 1))
        
        PREVIOUS_VERSION="v${PREVIOUS_MAJOR}.0.0"
        
        echo "Current version: $CURRENT_VERSION"
        echo "Previous version: $PREVIOUS_VERSION"
        
        # Check if current version (future release) exists in the repository
        CURRENT_TAG_EXISTS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          "https://api.github.com/repos/burnt-labs/xion/git/refs/tags/$CURRENT_VERSION" | \
          jq -r '.ref // "not_found"')
        
        if [[ "$CURRENT_TAG_EXISTS" == "not_found" ]]; then
          echo "âš ï¸  Current version $CURRENT_VERSION doesn't exist yet (future release)"
          echo "ðŸ“ Creating placeholder comparison data for future release documentation"
          
          # Create placeholder comparison data for future release
          COMPARISON_DATA='{"total_commits": "TBD", "files": [], "commits": [], "ahead_by": "TBD", "message": "Future release - comparison will be available when release is published"}'
          COMMIT_COUNT="TBD"
          FILES_CHANGED="TBD"
          
          echo "-- Using placeholder data for future release --"
        else
          # Get GitHub comparison data for existing releases
          COMPARISON_URL="https://api.github.com/repos/burnt-labs/xion/compare/$PREVIOUS_VERSION...$CURRENT_VERSION"
          echo "Fetching comparison from: $COMPARISON_URL"
          
          # Fetch the comparison data
          COMPARISON_DATA=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" "$COMPARISON_URL")
          
          # Check if the API response contains an error
          ERROR_MESSAGE=$(echo "$COMPARISON_DATA" | jq -r '.message // empty')
          
          if [[ "$ERROR_MESSAGE" == "Not Found" ]]; then
            echo "âš ï¸  Previous version $PREVIOUS_VERSION not found in GitHub"
            echo "ðŸ“ One of two versions doesn't exist"
            
            # Create empty comparison data
            COMPARISON_DATA='{"total_commits": 0, "files": [], "commits": []}'
            COMMIT_COUNT=0
            FILES_CHANGED=0
            
            echo "-- Using empty comparison data --"
          else
            echo "âœ… Successfully fetched comparison data"
            
            # Extract key information
            COMMIT_COUNT=$(echo "$COMPARISON_DATA" | jq -r '.total_commits // 0')
            FILES_CHANGED=$(echo "$COMPARISON_DATA" | jq -r '.files | length // 0')
          fi
        fi
        
        echo "Commits: $COMMIT_COUNT"
        echo "Files changed: $FILES_CHANGED"
        
        # Save comparison data to file for Claude API (even if placeholder)
        echo "$COMPARISON_DATA" > comparison_data.json
        
        # Set environment variables
        echo "PREVIOUS_VERSION=$PREVIOUS_VERSION" >> $GITHUB_ENV
        echo "COMMIT_COUNT=$COMMIT_COUNT" >> $GITHUB_ENV
        echo "FILES_CHANGED=$FILES_CHANGED" >> $GITHUB_ENV

    - name: Generate release notes with Claude API
      run: |
        # Decode the prompt from base64
        PROMPT=$(echo "$CLAUDE_PROMPT_B64" | base64 -d)
        
        # Replace placeholders with environment variables
        PROMPT="${PROMPT//\{\{RELEASE_TAG\}\}/${{ env.RELEASE_TAG }}}"
        PROMPT="${PROMPT//\{\{CALCULATED_HEIGHT\}\}/${{ env.CALCULATED_HEIGHT }}}"
        PROMPT="${PROMPT//\{\{PREVIOUS_VERSION\}\}/${{ env.PREVIOUS_VERSION }}}"
        
        echo "Loaded Claude API prompt from external file"
        
        # Call Claude API
        CLAUDE_RESPONSE=$(curl -s -X POST "https://api.anthropic.com/v1/messages" \
          -H "Content-Type: application/json" \
          -H "x-api-key: ${{ secrets.BURNT_CLAUDE_API_KEY }}" \
          -H "anthropic-version: 2023-06-01" \
          -d '{
            "model": "claude-3-sonnet-20240229",
            "max_tokens": 4000,
            "messages": [
              {
                "role": "user",
                "content": "'"$PROMPT"'\n\nGitHub Comparison Data:\n'"$(cat comparison_data.json | jq -c .)"'"
              }
            ]
          }')
        
        # Extract the response content
        RELEASE_NOTES_CONTENT=$(echo "$CLAUDE_RESPONSE" | jq -r '.content[0].text')
        
        # Save the generated release notes
        echo "$RELEASE_NOTES_CONTENT" > generated_release_notes.md
        
        echo "Generated release notes saved to generated_release_notes.md"
         
    - name: Use fallback template if Claude API fails
      run: |
        # Use the generated release notes if available, otherwise use template
        if [ -f "generated_release_notes.md" ]; then
          echo "Using AI-generated release notes"
          cp generated_release_notes.md release_notes_template.md
        else
          echo "Using fallback template (Claude API may have failed)"
          
          # Load fallback template from external file
          FALLBACK_TEMPLATE=$(cat .github/workflows/prompts/fallback-template.md)
          
          # Replace placeholders with environment variables
          FALLBACK_TEMPLATE="${FALLBACK_TEMPLATE//\{\{RELEASE_TAG\}\}/${{ env.RELEASE_TAG }}}"
          FALLBACK_TEMPLATE="${FALLBACK_TEMPLATE//\{\{CALCULATED_HEIGHT\}\}/${{ env.CALCULATED_HEIGHT }}}"
          FALLBACK_TEMPLATE="${FALLBACK_TEMPLATE//\{\{PREVIOUS_VERSION\}\}/${{ env.PREVIOUS_VERSION }}}"
          
          # Save the processed template
          echo "$FALLBACK_TEMPLATE" > release_notes_template.md
          echo "Created fallback template from external file"
        fi
        
    - name: Run release files creation script
      run: |
        ./scripts/create-release-pr.sh "${{ env.CALCULATED_HEIGHT }}" "${{ env.DEPOSIT }}" "${{ env.EXPEDITED }}" "${{ env.RELEASE_TAG }}"
        
    - name: debug - Echo release files
      run: |
        echo "-> Proposal file"
        cat proposals/038-upgrade-v22.json
        
        echo "-> Release file"
        cat releases/v22.json
        
        echo "-> Release notes file"
        cat release_notes/v22.md
        
    - name: Set environment variables from script output
      run: |
        # Find the actual files that were created (after script runs)
        VERSION_NUM=$(echo "${{ env.RELEASE_TAG }}" | sed 's/v\([0-9]*\)\.0\.0/\1/')
        VERSION="v${VERSION_NUM}"
        
        # Find the actual proposal file that was created/used by the script
        ACTUAL_PROPOSAL_FILE=$(find proposals/ -name "*-upgrade-${VERSION}.json" | head -1)
        if [ -z "$ACTUAL_PROPOSAL_FILE" ]; then
          # Fallback: predict the next number if no file found yet
          LATEST_PROPOSAL=$(ls proposals/ | grep -E '^[0-9]{3}-upgrade-v[0-9]+\.json$' | sort -V | tail -1)
          if [ -z "$LATEST_PROPOSAL" ]; then
            NEXT_NUM="001"
          else
            CURRENT_NUM=$(echo $LATEST_PROPOSAL | cut -d'-' -f1)
            NEXT_NUM=$(printf "%03d" $((10#$CURRENT_NUM + 1)))
          fi
          ACTUAL_PROPOSAL_FILE="proposals/${NEXT_NUM}-upgrade-${VERSION}.json"
        fi
        
        echo "PROPOSAL_FILE=$ACTUAL_PROPOSAL_FILE" >> $GITHUB_ENV
        echo "RELEASE_FILE=releases/$VERSION.json" >> $GITHUB_ENV
        echo "RELEASE_NOTES_FILE=release_notes/$VERSION.md" >> $GITHUB_ENV
        
    - name: Stage changes for PR creation
      run: |
        # Check if any of the created files have changes and stage them
        CHANGES_DETECTED=false
        COMMIT_MESSAGE_PARTS=()
        
        # Check each file individually and add only if changed
        for file in "${{ env.PROPOSAL_FILE }}" "${{ env.RELEASE_FILE }}" "${{ env.RELEASE_NOTES_FILE }}"; do
          if [ -f "$file" ]; then
            # Check if file has changes (new file or modified)
            if git diff --quiet "$file" 2>/dev/null; then
              echo "â„¹ï¸  No changes in $file (reused existing file)"
            else
              echo "ðŸ“ Changes detected in $file"
              git add "$file"
              CHANGES_DETECTED=true
              
              # Add appropriate message based on file type
              if [[ "$file" == *"proposal"* ]]; then
                COMMIT_MESSAGE_PARTS+=("- Updated proposal: $file")
              elif [[ "$file" == *"release"* && "$file" == *".json" ]]; then
                COMMIT_MESSAGE_PARTS+=("- Updated release config: $file")
              elif [[ "$file" == *"release_notes"* ]]; then
                COMMIT_MESSAGE_PARTS+=("- Updated release notes: $file")
              fi
            fi
          else
            echo "âš ï¸  File $file does not exist"
          fi
        done
        
        # Build commit message for peter-evans action to use
        if [ "$CHANGES_DETECTED" = true ]; then
          {
            echo "Release ${{ env.VERSION }} update"
            echo ""
            printf '%s\n' "${COMMIT_MESSAGE_PARTS[@]}"
            echo ""
            echo "Configuration:"
            echo "- Release Tag: ${{ env.RELEASE_TAG }}"
            echo "- Upgrade Height: ${{ env.CALCULATED_HEIGHT }} (calculated: 2 days from current block)"
            echo "- Deposit: ${{ env.DEPOSIT }}"
            echo "- Expedited: ${{ env.EXPEDITED }}"
          } > pr_commit_message.txt
          echo "âœ… File changes staged for PR creation"
        else
          {
            echo "Update PR: Refresh upgrade parameters for ${{ env.VERSION }}"
            echo ""
            echo "Configuration refresh:"
            echo "- Release Tag: ${{ env.RELEASE_TAG }}"
            echo "- Upgrade Height: ${{ env.CALCULATED_HEIGHT }} (calculated 2 days from current block)"
            echo "- Deposit: ${{ env.DEPOSIT }}"
            echo "- Expedited: ${{ env.EXPEDITED }}"
            echo "- Run: ${{ github.run_number }}"
          } > pr_commit_message.txt
          echo "â„¹ï¸  No file changes detected - peter-evans action will handle empty commit if needed"
        fi
        
        # Set environment variable for peter-evans action
        echo "COMMIT_MESSAGE_FILE=pr_commit_message.txt" >> $GITHUB_ENV
        
    - name: Prepare comprehensive PR body
      run: |
        # Generate comprehensive PR body using external script
        ./scripts/generate-pr-body.sh "${{ env.VERSION }}" "${{ env.CALCULATED_HEIGHT }}" "${{ env.DEPOSIT }}" "${{ env.EXPEDITED }}" "${{ env.PROPOSAL_FILE }}" "${{ env.RELEASE_FILE }}" "${{ env.RELEASE_NOTES_FILE }}" "${{ env.RELEASE_TAG }}" "${{ env.COMMIT_COUNT }}" "${{ env.FILES_CHANGED }}" "${{ env.PREVIOUS_VERSION }}" "${{ env.DARWIN_AMD64_CHECKSUM }}" "${{ env.DARWIN_ARM64_CHECKSUM }}" "${{ env.LINUX_AMD64_CHECKSUM }}" "${{ env.LINUX_ARM64_CHECKSUM }}" "${{ github.run_number }}" "${{ github.sha }}"
        
        echo "PR_BODY_FILE=pr_body.md" >> $GITHUB_ENV
        
    - name: Create or Update Pull Request
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # Check if we have any staged files or changes to commit
        if git diff --cached --quiet && git diff --quiet; then
          echo "No changes detected, but creating empty commit to update PR parameters"
          # Read the commit message from file
          COMMIT_MSG=$(cat pr_commit_message.txt)
          git commit --allow-empty -m "$COMMIT_MSG"
        else
          echo "Changes detected, committing staged files"
          # Read the commit message from file  
          COMMIT_MSG=$(cat pr_commit_message.txt)
          git commit -m "$COMMIT_MSG"
        fi
        
        # Push the changes
        git push origin "${{ env.BRANCH_NAME }}"
        
        # Check if PR already exists
        EXISTING_PR=$(gh pr list --head "${{ env.BRANCH_NAME }}" --base "${{ env.TARGET_BRANCH }}" --json number --jq '.[0].number' 2>/dev/null || echo "")
        
        if [ -n "$EXISTING_PR" ] && [ "$EXISTING_PR" != "null" ]; then
          echo "Updating existing PR #$EXISTING_PR"
          # Update existing PR body
          gh pr edit "$EXISTING_PR" --body-file pr_body.md
          echo "âœ… Updated existing PR #$EXISTING_PR"
        else
          echo "Creating new PR"
          gh pr create \
            --base "${{ env.TARGET_BRANCH }}" \
            --head "${{ env.BRANCH_NAME }}" \
            --title "ðŸš€ Upgrade to Xion ${{ env.RELEASE_TAG }}" \
            --body-file pr_body.md
          echo "âœ… PR created successfully"
        fi
        
    - name: Workflow Summary
      run: |
        echo "## ðŸ“‹ Workflow Summary"
        echo ""
        echo "âœ… PR has been created/updated for release ${{ env.RELEASE_TAG }}"
        echo "   - Proposal: ${{ env.PROPOSAL_FILE }}"
        echo "   - Release config: ${{ env.RELEASE_FILE }}"
        echo "   - Release notes: ${{ env.RELEASE_NOTES_FILE }}"
        echo ""
        echo "ðŸ”„ Configuration for this run:"
        echo "   - Release Tag: ${{ env.RELEASE_TAG }}"
        echo "   - Upgrade Height: ${{ env.CALCULATED_HEIGHT }}"
        echo "   - Deposit: ${{ env.DEPOSIT }}"
        echo "   - Expedited: ${{ env.EXPEDITED }}"
        echo "   - Run Number: ${{ github.run_number }}"


name: Create Release PR 

on:
  push:
    branches:
      # - main
      # - master
      - feat/do-85-generate-upgrade-proposals-n-release-binaries

  workflow_dispatch: # NOTICE: To trigger the workflow_dispatch event, the workflow must be in the default branch.
    inputs:
      release_tag:
        description: 'Release tag to update the chain registry with'
        required: true
        type: string
      deposit:
        description: 'Deposit amount (default: 1000000000uxion)'
        required: false
        default: '1000000000uxion'
        type: string
      expedited:
        description: 'Expedited proposal'
        required: false
        default: false
        type: boolean

env:
  # API endpoints
  XION_TESTNET_API: "https://api.xion-testnet-2.burnt.com/cosmos/base/tendermint/v1beta1"
  
  # Input values from workflow_dispatch
  # RELEASE_TAG: ${{ github.event.inputs.release_tag }}
  RELEASE_TAG: v22.0.0 # TODO : delete this
  DEPOSIT: 1000000000uxion
  EXPEDITED: false
  
  # Placeholder values for binary checksums
  PLACEHOLDER_CHECKSUM_DARWIN_AMD64: "--ADD-HERE-YOUR-VALUE--"
  PLACEHOLDER_CHECKSUM_DARWIN_ARM64: "--ADD-HERE-YOUR-VALUE--"
  PLACEHOLDER_CHECKSUM_LINUX_AMD64: "--ADD-HERE-YOUR-VALUE--"
  PLACEHOLDER_CHECKSUM_LINUX_ARM64: "--ADD-HERE-YOUR-VALUE--"

jobs:
  create-release-pr:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Load prompts into environment variables before switching branches  
      run: |
        # Load prompts using base64 to avoid delimiter issues
        CLAUDE_PROMPT_B64=$(cat .github/workflows/prompts/claude-api-prompt.md | base64 -w 0)
        echo "CLAUDE_PROMPT_B64=$CLAUDE_PROMPT_B64" >> $GITHUB_ENV
        
        FALLBACK_PROMPT_B64=$(cat .github/workflows/prompts/fallback-template.md | base64 -w 0)
        echo "FALLBACK_PROMPT_B64=$FALLBACK_PROMPT_B64" >> $GITHUB_ENV

    - name: Prepare branch variables and checkout
      run: |
        # Extract version from RELEASE_TAG and set branch name
        VERSION_NUM=$(echo "${{ env.RELEASE_TAG }}" | sed 's/v\([0-9]*\)\.0\.0/\1/')
        VERSION="v${VERSION_NUM}"
        BRANCH_NAME="release/${{ env.RELEASE_TAG }}"
        
        echo "VERSION=$VERSION" >> $GITHUB_ENV
        echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
        
        # Set up git config
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Fetch all remote branches to ensure we have latest refs
        git fetch origin
        
        # Check if remote branch exists and handle accordingly
        if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
          echo "Remote branch $BRANCH_NAME exists, checking out and pulling latest changes"
          
          # Check if local branch exists
          if git show-ref --verify --quiet refs/heads/"$BRANCH_NAME"; then
            echo "Local branch exists, switching to it"
            git checkout "$BRANCH_NAME"
          else
            echo "Local branch doesn't exist, creating from remote"
            git checkout -b "$BRANCH_NAME" origin/"$BRANCH_NAME"
          fi
          
          # Pull latest changes from remote to avoid conflicts
          git pull origin "$BRANCH_NAME"
          
        else
          echo "Remote branch $BRANCH_NAME doesn't exist, creating new branch"
          git checkout -b "$BRANCH_NAME"
        fi
        
    - name: Calculate block height
      run: |
        # Get current block height and timestamp
        CURRENT_BLOCK=$(curl -s -X 'GET' "${{ env.XION_TESTNET_API }}/blocks/latest" -H 'accept: application/json' | jq -r '.block.header.height')
        CURRENT_TIME=$(curl -s -X 'GET' "${{ env.XION_TESTNET_API }}/blocks/latest" -H 'accept: application/json' | jq -r '.block.header.time')
        
        echo "Current block: $CURRENT_BLOCK"
        echo "Current time: $CURRENT_TIME"
        
        # Get block from 10000 blocks ago
        OLD_BLOCK=$((CURRENT_BLOCK - 10000))
        OLD_BLOCK_INFO=$(curl -s -X 'GET' "${{ env.XION_TESTNET_API }}/blocks/$OLD_BLOCK" -H 'accept: application/json' | jq -r '.block.header.time')
        
        echo "Old block ($OLD_BLOCK) time: $OLD_BLOCK_INFO"
        
        # Calculate average block time (in seconds)
        CURRENT_TIMESTAMP=$(date -d "$CURRENT_TIME" +%s)
        OLD_TIMESTAMP=$(date -d "$OLD_BLOCK_INFO" +%s)
        TIME_DIFF=$((CURRENT_TIMESTAMP - OLD_TIMESTAMP))
        AVERAGE_BLOCK_TIME=$(echo "scale=2; $TIME_DIFF / 10000" | bc)
        
        echo "Average block time: ${AVERAGE_BLOCK_TIME} seconds"
        
        # Calculate blocks for 2 days (172800 seconds)
        BLOCKS_IN_2_DAYS=$(echo "scale=0; 172800 / $AVERAGE_BLOCK_TIME" | bc)
        
        # Calculate target block height (round to nearest 1000)
        TARGET_BLOCKS=$((BLOCKS_IN_2_DAYS + CURRENT_BLOCK))
        ROUNDED_BLOCKS=$(( (TARGET_BLOCKS + 500) / 1000 * 1000 ))
        
        echo "Blocks in 2 days: $BLOCKS_IN_2_DAYS"
        echo "Target block height: $ROUNDED_BLOCKS"
        
        # Set the calculated height as environment variable
        echo "CALCULATED_HEIGHT=$ROUNDED_BLOCKS" >> $GITHUB_ENV

    - name: Fetch release checksums
      run: |
        # Construct the checksums URL for the release
        CHECKSUMS_URL="https://github.com/burnt-labs/xion/releases/download/${{ env.RELEASE_TAG }}/xiond-${{ env.RELEASE_TAG }}-checksums.txt"
        echo "Fetching checksums from: $CHECKSUMS_URL"
        
        # Try to fetch the checksums file
        CHECKSUMS_RESPONSE=$(curl -s -w "%{http_code}" "$CHECKSUMS_URL" -o checksums_temp.txt)
        HTTP_CODE="${CHECKSUMS_RESPONSE: -3}"
        
        if [ "$HTTP_CODE" = "200" ]; then
          echo "âœ… Successfully fetched checksums for ${{ env.RELEASE_TAG }}"
          
          # Parse the checksums file and extract values
          CHECKS_FILE="checksums_temp.txt"
          
          # Extract checksums for different platforms
          DARWIN_AMD64_CHECKSUM=$(grep "darwin_amd64.tar.gz" "$CHECKS_FILE" | awk '{print $1}')
          DARWIN_ARM64_CHECKSUM=$(grep "darwin_arm64.tar.gz" "$CHECKS_FILE" | awk '{print $1}')
          LINUX_AMD64_CHECKSUM=$(grep "linux_amd64.tar.gz" "$CHECKS_FILE" | awk '{print $1}')
          LINUX_ARM64_CHECKSUM=$(grep "linux_arm64.tar.gz" "$CHECKS_FILE" | awk '{print $1}')
          
          # Set environment variables with real checksums
          echo "DARWIN_AMD64_CHECKSUM=$DARWIN_AMD64_CHECKSUM" >> $GITHUB_ENV
          echo "DARWIN_ARM64_CHECKSUM=$DARWIN_ARM64_CHECKSUM" >> $GITHUB_ENV
          echo "LINUX_AMD64_CHECKSUM=$LINUX_AMD64_CHECKSUM" >> $GITHUB_ENV
          echo "LINUX_ARM64_CHECKSUM=$LINUX_ARM64_CHECKSUM" >> $GITHUB_ENV
          
          echo "âœ… Using real checksums:"
          echo "  Darwin AMD64: $DARWIN_AMD64_CHECKSUM"
          echo "  Darwin ARM64: $DARWIN_ARM64_CHECKSUM"
          echo "  Linux AMD64: $LINUX_AMD64_CHECKSUM"
          echo "  Linux ARM64: $LINUX_ARM64_CHECKSUM"
          
        else
          echo "âš ï¸  Checksums file not found for ${{ env.RELEASE_TAG }} (HTTP $HTTP_CODE)"
          if [ "$HTTP_CODE" = "404" ]; then
            echo "ðŸ“ This appears to be a future release - checksums will be available when the release is published"
          fi
          echo "ðŸ“ Using placeholder values for now"
          
          # Set environment variables with placeholder values
          echo "DARWIN_AMD64_CHECKSUM=${{ env.PLACEHOLDER_CHECKSUM_DARWIN_AMD64 }}" >> $GITHUB_ENV
          echo "DARWIN_ARM64_CHECKSUM=${{ env.PLACEHOLDER_CHECKSUM_DARWIN_ARM64 }}" >> $GITHUB_ENV
          echo "LINUX_AMD64_CHECKSUM=${{ env.PLACEHOLDER_CHECKSUM_LINUX_AMD64 }}" >> $GITHUB_ENV
          echo "LINUX_ARM64_CHECKSUM=${{ env.PLACEHOLDER_CHECKSUM_LINUX_ARM64 }}" >> $GITHUB_ENV
          
          echo "ðŸ“ Using placeholder checksums (will be updated when release is available)"
        fi
        
        # Clean up temporary file
        rm -f checksums_temp.txt
  
    - name: Get GitHub comparison data
      run: |
        # Extract version number from release tag
        CURRENT_VERSION="${{ env.RELEASE_TAG }}"
        # Extract major version number and calculate previous version
        CURRENT_MAJOR=$(echo "$CURRENT_VERSION" | sed 's/v\([0-9]*\)\.0\.0/\1/')
        PREVIOUS_MAJOR=$((CURRENT_MAJOR - 1))
        
        PREVIOUS_VERSION="v${PREVIOUS_MAJOR}.0.0"
        
        echo "Current version: $CURRENT_VERSION"
        echo "Previous version: $PREVIOUS_VERSION"
        
        # Check if current version (future release) exists in the repository
        CURRENT_TAG_EXISTS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          "https://api.github.com/repos/burnt-labs/xion/git/refs/tags/$CURRENT_VERSION" | \
          jq -r '.ref // "not_found"')
        
        if [[ "$CURRENT_TAG_EXISTS" == "not_found" ]]; then
          echo "âš ï¸  Current version $CURRENT_VERSION doesn't exist yet (future release)"
          echo "ðŸ“ Creating placeholder comparison data for future release documentation"
          
          # Create placeholder comparison data for future release
          COMPARISON_DATA='{"total_commits": "TBD", "files": [], "commits": [], "ahead_by": "TBD", "message": "Future release - comparison will be available when release is published"}'
          COMMIT_COUNT="TBD"
          FILES_CHANGED="TBD"
          
          echo "-- Using placeholder data for future release --"
        else
          # Get GitHub comparison data for existing releases
          COMPARISON_URL="https://api.github.com/repos/burnt-labs/xion/compare/$PREVIOUS_VERSION...$CURRENT_VERSION"
          echo "Fetching comparison from: $COMPARISON_URL"
          
          # Fetch the comparison data
          COMPARISON_DATA=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" "$COMPARISON_URL")
          
          # Check if the API response contains an error
          ERROR_MESSAGE=$(echo "$COMPARISON_DATA" | jq -r '.message // empty')
          
          if [[ "$ERROR_MESSAGE" == "Not Found" ]]; then
            echo "âš ï¸  Previous version $PREVIOUS_VERSION not found in GitHub"
            echo "ðŸ“ One of two versions doesn't exist"
            
            # Create empty comparison data
            COMPARISON_DATA='{"total_commits": 0, "files": [], "commits": []}'
            COMMIT_COUNT=0
            FILES_CHANGED=0
            
            echo "-- Using empty comparison data --"
          else
            echo "âœ… Successfully fetched comparison data"
            
            # Extract key information
            COMMIT_COUNT=$(echo "$COMPARISON_DATA" | jq -r '.total_commits // 0')
            FILES_CHANGED=$(echo "$COMPARISON_DATA" | jq -r '.files | length // 0')
          fi
        fi
        
        echo "Commits: $COMMIT_COUNT"
        echo "Files changed: $FILES_CHANGED"
        
        # Save comparison data to file for Claude API (even if placeholder)
        echo "$COMPARISON_DATA" > comparison_data.json
        
        # Set environment variables
        echo "PREVIOUS_VERSION=$PREVIOUS_VERSION" >> $GITHUB_ENV
        echo "COMMIT_COUNT=$COMMIT_COUNT" >> $GITHUB_ENV
        echo "FILES_CHANGED=$FILES_CHANGED" >> $GITHUB_ENV

    - name: Generate release notes with Claude API
      run: |
        # Decode the prompt from base64
        PROMPT=$(echo "$CLAUDE_PROMPT_B64" | base64 -d)
        
        # Replace placeholders with environment variables
        PROMPT="${PROMPT//\{\{RELEASE_TAG\}\}/${{ env.RELEASE_TAG }}}"
        PROMPT="${PROMPT//\{\{CALCULATED_HEIGHT\}\}/${{ env.CALCULATED_HEIGHT }}}"
        PROMPT="${PROMPT//\{\{PREVIOUS_VERSION\}\}/${{ env.PREVIOUS_VERSION }}}"
        
        echo "Loaded Claude API prompt from external file"
        
        # Call Claude API
        CLAUDE_RESPONSE=$(curl -s -X POST "https://api.anthropic.com/v1/messages" \
          -H "Content-Type: application/json" \
          -H "x-api-key: ${{ secrets.BURNT_CLAUDE_API_KEY }}" \
          -H "anthropic-version: 2023-06-01" \
          -d '{
            "model": "claude-3-sonnet-20240229",
            "max_tokens": 4000,
            "messages": [
              {
                "role": "user",
                "content": "'"$PROMPT"'\n\nGitHub Comparison Data:\n'"$(cat comparison_data.json | jq -c .)"'"
              }
            ]
          }')
        
        # Extract the response content
        RELEASE_NOTES_CONTENT=$(echo "$CLAUDE_RESPONSE" | jq -r '.content[0].text')
        
        # Save the generated release notes
        echo "$RELEASE_NOTES_CONTENT" > generated_release_notes.md
        
        echo "Generated release notes saved to generated_release_notes.md"
         
    - name: Use fallback template if Claude API fails
      run: |
        # Use the generated release notes if available, otherwise use template
        if [ -f "generated_release_notes.md" ]; then
          echo "Using AI-generated release notes"
          cp generated_release_notes.md release_notes_template.md
        else
          echo "Using fallback template (Claude API may have failed)"
          
          # Load fallback template from external file
          FALLBACK_TEMPLATE=$(cat .github/workflows/prompts/fallback-template.md)
          
          # Replace placeholders with environment variables
          FALLBACK_TEMPLATE="${FALLBACK_TEMPLATE//\{\{RELEASE_TAG\}\}/${{ env.RELEASE_TAG }}}"
          FALLBACK_TEMPLATE="${FALLBACK_TEMPLATE//\{\{CALCULATED_HEIGHT\}\}/${{ env.CALCULATED_HEIGHT }}}"
          FALLBACK_TEMPLATE="${FALLBACK_TEMPLATE//\{\{PREVIOUS_VERSION\}\}/${{ env.PREVIOUS_VERSION }}}"
          
          # Save the processed template
          echo "$FALLBACK_TEMPLATE" > release_notes_template.md
          echo "Created fallback template from external file"
        fi
        
    - name: Run release files creation script
      run: |
        ./scripts/create-release-pr.sh "${{ env.CALCULATED_HEIGHT }}" "${{ env.DEPOSIT }}" "${{ env.EXPEDITED }}" "${{ env.RELEASE_TAG }}"
        
    - name: debug - Echo release files
      run: |
        echo "-> Proposal file"
        cat proposals/038-upgrade-v22.json
        
        echo "-> Release file"
        cat releases/v22.json
        
        echo "-> Release notes file"
        cat release_notes/v22.md
        
    - name: Set environment variables from script output
      run: |
        # Find the actual files that were created (after script runs)
        VERSION_NUM=$(echo "${{ env.RELEASE_TAG }}" | sed 's/v\([0-9]*\)\.0\.0/\1/')
        VERSION="v${VERSION_NUM}"
        
        # Find the actual proposal file that was created/used by the script
        ACTUAL_PROPOSAL_FILE=$(find proposals/ -name "*-upgrade-${VERSION}.json" | head -1)
        if [ -z "$ACTUAL_PROPOSAL_FILE" ]; then
          # Fallback: predict the next number if no file found yet
          LATEST_PROPOSAL=$(ls proposals/ | grep -E '^[0-9]{3}-upgrade-v[0-9]+\.json$' | sort -V | tail -1)
          if [ -z "$LATEST_PROPOSAL" ]; then
            NEXT_NUM="001"
          else
            CURRENT_NUM=$(echo $LATEST_PROPOSAL | cut -d'-' -f1)
            NEXT_NUM=$(printf "%03d" $((10#$CURRENT_NUM + 1)))
          fi
          ACTUAL_PROPOSAL_FILE="proposals/${NEXT_NUM}-upgrade-${VERSION}.json"
        fi
        
        echo "PROPOSAL_FILE=$ACTUAL_PROPOSAL_FILE" >> $GITHUB_ENV
        echo "RELEASE_FILE=releases/$VERSION.json" >> $GITHUB_ENV
        echo "RELEASE_NOTES_FILE=release_notes/$VERSION.md" >> $GITHUB_ENV
        
    - name: Commit and push changes
      run: |
        # Check if any of the created files have changes
        CHANGES_DETECTED=false
        COMMIT_MESSAGE_PARTS=()
        
        # Check each file individually and add only if changed
        for file in "${{ env.PROPOSAL_FILE }}" "${{ env.RELEASE_FILE }}" "${{ env.RELEASE_NOTES_FILE }}"; do
          if [ -f "$file" ]; then
            # Check if file has changes (new file or modified)
            if git diff --quiet "$file" 2>/dev/null; then
              echo "â„¹ï¸  No changes in $file (reused existing file)"
            else
              echo "ðŸ“ Changes detected in $file"
              git add "$file"
              CHANGES_DETECTED=true
              
              # Add appropriate message based on file type
              if [[ "$file" == *"proposal"* ]]; then
                COMMIT_MESSAGE_PARTS+=("- Updated proposal: $file")
              elif [[ "$file" == *"release"* && "$file" == *".json" ]]; then
                COMMIT_MESSAGE_PARTS+=("- Updated release config: $file")
              elif [[ "$file" == *"release_notes"* ]]; then
                COMMIT_MESSAGE_PARTS+=("- Updated release notes: $file")
              fi
            fi
          else
            echo "âš ï¸  File $file does not exist"
          fi
        done
        
        # Always push branch to ensure PR can be created/updated
        if [ "$CHANGES_DETECTED" = true ]; then
          # Build commit message from actual changes
          COMMIT_MSG="Release ${{ env.VERSION }} update
          
          $(printf '%s\n' "${COMMIT_MESSAGE_PARTS[@]}")
          
          Configuration:
          - Release Tag: ${{ env.RELEASE_TAG }}
          - Upgrade Height: ${{ env.CALCULATED_HEIGHT }} (calculated: 2 days from current block)
          - Deposit: ${{ env.DEPOSIT }}
          - Expedited: ${{ env.EXPEDITED }}"

          git commit -m "$COMMIT_MSG"
          echo "âœ… File changes committed"
        else
          echo "â„¹ï¸  No file changes detected - all files already exist with identical content"
          # Create empty commit to trigger PR update
          git commit --allow-empty -m "Update PR: Refresh upgrade parameters for ${{ env.VERSION }}

Configuration refresh:
- Release Tag: ${{ env.RELEASE_TAG }}
- Upgrade Height: ${{ env.CALCULATED_HEIGHT }} (calculated: 2 days from current block)  
- Deposit: ${{ env.DEPOSIT }}
- Expedited: ${{ env.EXPEDITED }}
- Run: ${{ github.run_number }}"
          echo "âœ… Empty commit created to update PR"
        fi
        
        # Always push the branch  
        git push origin "${{ env.BRANCH_NAME }}"
        echo "âœ… Branch pushed - PR will be created/updated"
        
    - name: Prepare comprehensive PR body
    # if: env.SKIP_PR_CREATION != 'true'
      run: |
        # Extract proposal number from filename
        PROPOSAL_NUM=$(basename "${{ env.PROPOSAL_FILE }}" | cut -d'-' -f1)
        
        # Create comprehensive PR body with placeholders
        cat > pr_body.md << EOF
        # ðŸš€ Xion ${{ env.RELEASE_TAG }} Upgrade
        
        This pull request implements the upgrade to **Xion ${{ env.RELEASE_TAG }}** for the Xion testnet.
        
        ## ðŸ“‹ Overview
        
        - **Upgrade Height**: \`${{ env.CALCULATED_HEIGHT }}\` (estimated: ~2 days from current block)
        - **Chain ID**: \`xion-testnet-2\` (in-place migration)
        - **Release**: https://github.com/burnt-labs/xion/releases/tag/${{ env.RELEASE_TAG }}
        - **Proposal**: \`${{ env.PROPOSAL_FILE }}\`
        - **Governance Deposit**: ${{ env.DEPOSIT }}
        - **Expedited**: ${{ env.EXPEDITED }}
        
        ## ðŸ“Š Changes Summary
        
        EOF
        
        # Add comparison data if available
        if [[ "${{ env.COMMIT_COUNT }}" != "TBD" && "${{ env.COMMIT_COUNT }}" != "0" ]]; then
          cat >> pr_body.md << EOF
        - **Commits since last version**: ${{ env.COMMIT_COUNT }}
        - **Files changed**: ${{ env.FILES_CHANGED }}
        - **Changelog**: [Compare ${{ env.PREVIOUS_VERSION }}...${{ env.RELEASE_TAG }}](https://github.com/burnt-labs/xion/compare/${{ env.PREVIOUS_VERSION }}...${{ env.RELEASE_TAG }})
        
        EOF
        else
          cat >> pr_body.md << EOF
        - **Status**: Future release (comparison data will be available when release is published)
        - **Changelog**: Will be available at [Compare ${{ env.PREVIOUS_VERSION }}...${{ env.RELEASE_TAG }}](https://github.com/burnt-labs/xion/compare/${{ env.PREVIOUS_VERSION }}...${{ env.RELEASE_TAG }})
        
        EOF
        fi
        
        cat >> pr_body.md << EOF
        ## ðŸ“ Files Modified
        
        ### Governance & Upgrade Files
        - **Proposal**: \`${{ env.PROPOSAL_FILE }}\`
          - Upgrade height: \`${{ env.CALCULATED_HEIGHT }}\`
          - Chain upgrade to ${{ env.RELEASE_TAG }}
          - Points to release config: \`${{ env.RELEASE_FILE }}\`
        
        - **Release Config**: \`${{ env.RELEASE_FILE }}\`
          - Binary URLs for all platforms (darwin/linux, amd64/arm64)
          - SHA256 checksums for security verification
        
        - **Release Notes**: \`${{ env.RELEASE_NOTES_FILE }}\`
          - Detailed changelog and upgrade information
          - Generated using AI analysis of GitHub comparison data
        
        ## ðŸ”’ Security & Verification
        
        ### Binary Checksums
        EOF
        
        # Add checksum information
        if [[ "${{ env.DARWIN_AMD64_CHECKSUM }}" != *"--ADD-HERE-YOUR-VALUE--"* ]]; then
          cat >> pr_body.md << EOF
        
        âœ… **Real checksums** (fetched from GitHub release):
        - **Darwin AMD64**: \`${{ env.DARWIN_AMD64_CHECKSUM }}\`
        - **Darwin ARM64**: \`${{ env.DARWIN_ARM64_CHECKSUM }}\`  
        - **Linux AMD64**: \`${{ env.LINUX_AMD64_CHECKSUM }}\`
        - **Linux ARM64**: \`${{ env.LINUX_ARM64_CHECKSUM }}\`
        EOF
        else
          cat >> pr_body.md << EOF
        
        âš ï¸ **Placeholder checksums** (release not yet published):
        - Checksums will be updated automatically when ${{ env.RELEASE_TAG }} is released
        - Binary URLs point to the expected release location
        EOF
        fi
        
        cat >> pr_body.md << EOF
        
        ## âš ï¸ Important Notes for Validators
        
        ### Pre-Upgrade Checklist
        - [ ] **Backup**: Full snapshot of \`.xiond\` directory
        - [ ] **Critical**: Backup \`.xiond/data/priv_validator_state.json\` after stopping node
        - [ ] **Verify**: Binary version before starting post-upgrade
        - [ ] **Monitor**: Network upgrade progress
        
        ### System Requirements
        - **RAM**: 16GB recommended for smooth upgrade
        - **Disk**: Ensure sufficient space for state growth
        - **Network**: Stable connection during upgrade window
        
        ### Upgrade Process
        1. **Wait** for upgrade height \`${{ env.CALCULATED_HEIGHT }}\`
        2. **Node will panic** with upgrade message at target height
        3. **Stop node** and switch to ${{ env.RELEASE_TAG }} binary
        4. **Restart** with \`xiond start\`
        5. **Monitor** for successful chain continuation
        
        ### Emergency Procedures
        \`\`\`bash
        # Skip upgrade if issues occur
        xiond start --unsafe-skip-upgrade ${{ env.CALCULATED_HEIGHT }}
        \`\`\`
        
        ## ðŸ”— Resources
        
        - **GitHub Release**: https://github.com/burnt-labs/xion/releases/tag/${{ env.RELEASE_TAG }}
        - **Upgrade Proposal**: \`${{ env.PROPOSAL_FILE }}\`
        - **Technical Documentation**: \`${{ env.RELEASE_NOTES_FILE }}\`
        - **Support**: Join Xion Discord/Telegram for upgrade assistance
        
        ## ðŸ§ª Testing Status
        
        - [x] Proposal JSON validation
        - [x] Release config validation  
        - [x] Binary URL format verification
        - [x] Checksum integration
        - [x] Height calculation (2-day buffer)
        
        ---
        
        **âš¡ Automation Notes**: This PR was automatically generated with intelligent duplicate detection. Files are only updated when content changes, and identical configurations reuse existing proposals to prevent iteration spam.
        
        **ðŸ”„ Run Details**: 
        - Workflow run: ${{ github.run_number }}
        - Commit: \`${{ github.sha }}\`
        - Timestamp: \`$(date -u '+%Y-%m-%d %H:%M:%S UTC')\`
        - Trigger: ${{ github.event_name }}
        
        **ðŸ”„ Latest Update**: This PR is automatically updated each time the workflow runs to reflect current blockchain state and calculated values.
        
        EOF
        
        # Add AI-generated release notes if available
        if [ -f "generated_release_notes.md" ]; then
          echo "" >> pr_body.md
          echo "## ðŸ“ Detailed Release Notes" >> pr_body.md
          echo "" >> pr_body.md
          echo "<details>" >> pr_body.md
          echo "<summary>Click to expand AI-generated upgrade guide</summary>" >> pr_body.md
          echo "" >> pr_body.md
          echo '```markdown' >> pr_body.md
          cat generated_release_notes.md >> pr_body.md
          echo '```' >> pr_body.md
          echo "</details>" >> pr_body.md
        fi
        
        echo "PR_BODY_FILE=pr_body.md" >> $GITHUB_ENV
        
    - name: Create or Update Pull Request
      # if: env.SKIP_PR_CREATION != 'true'
      uses: peter-evans/create-pull-request@v5 # https://github.com/peter-evans/create-pull-request?tab=readme-ov-file
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        branch: ${{ env.BRANCH_NAME }}  # Source: release/vXX.0.0
        base: feat/do-85-generate-upgrade-proposals-n-release-binaries   # TODO Target: main
        title: "ðŸš€ Upgrade to Xion ${{ env.RELEASE_TAG }} (Height: ${{ env.CALCULATED_HEIGHT }})"
        reviewers: wehappyfew,2xburnt
        body-path: pr_body.md
        delete-branch: false
        # Force update the PR description even if no file changes
        force: true
        
    - name: Workflow Summary
      run: |
        echo "## ðŸ“‹ Workflow Summary"
        echo ""
        echo "âœ… PR has been created/updated for release ${{ env.RELEASE_TAG }}"
        echo "   - Proposal: ${{ env.PROPOSAL_FILE }}"
        echo "   - Release config: ${{ env.RELEASE_FILE }}"
        echo "   - Release notes: ${{ env.RELEASE_NOTES_FILE }}"
        echo ""
        echo "ðŸ”„ Configuration for this run:"
        echo "   - Release Tag: ${{ env.RELEASE_TAG }}"
        echo "   - Upgrade Height: ${{ env.CALCULATED_HEIGHT }}"
        echo "   - Deposit: ${{ env.DEPOSIT }}"
        echo "   - Expedited: ${{ env.EXPEDITED }}"
        echo "   - Run Number: ${{ github.run_number }}"

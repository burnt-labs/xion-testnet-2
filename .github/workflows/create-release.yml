name: Create Release PR 

on:
  push:
    branches:
      # - main
      # - master
      - feat/do-85-generate-upgrade-proposals-n-release-binaries

  workflow_dispatch: # NOTICE: To trigger the workflow_dispatch event, the workflow must be in the default branch.
    inputs:
      release_tag:
        description: 'Release tag to update the chain registry with'
        required: true
        type: string
      deposit:
        description: 'Deposit amount (default: 1000000000uxion)'
        required: false
        default: '1000000000uxion'
        type: string
      expedited:
        description: 'Expedited proposal'
        required: false
        default: false
        type: boolean

env:
  # API endpoints
  XION_TESTNET_API: "https://api.xion-testnet-2.burnt.com/cosmos/base/tendermint/v1beta1"
  
  # Input values from workflow_dispatch
  # RELEASE_TAG: ${{ github.event.inputs.release_tag }}
  RELEASE_TAG: v22.0.0 # TODO : delete this
  DEPOSIT: 1000000000uxion
  EXPEDITED: false
  
  # Placeholder values for binary checksums
  PLACEHOLDER_CHECKSUM_DARWIN_AMD64: "--ADD-HERE-YOUR-VALUE--"
  PLACEHOLDER_CHECKSUM_DARWIN_ARM64: "--ADD-HERE-YOUR-VALUE--"
  PLACEHOLDER_CHECKSUM_LINUX_AMD64: "--ADD-HERE-YOUR-VALUE--"
  PLACEHOLDER_CHECKSUM_LINUX_ARM64: "--ADD-HERE-YOUR-VALUE--"

jobs:
  create-release-pr:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Prepare branch variables and checkout
      run: |
        # Extract version from RELEASE_TAG and set branch name
        VERSION_NUM=$(echo "${{ env.RELEASE_TAG }}" | sed 's/v\([0-9]*\)\.0\.0/\1/')
        VERSION="v${VERSION_NUM}"
        BRANCH_NAME="release/${{ env.RELEASE_TAG }}"
        
        echo "VERSION=$VERSION" >> $GITHUB_ENV
        echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
        
        # Set up git config
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Fetch all remote branches to ensure we have latest refs
        git fetch origin
        
        # Check if remote branch exists and handle accordingly
        if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
          echo "Remote branch $BRANCH_NAME exists, checking out and pulling latest changes"
          
          # Check if local branch exists
          if git show-ref --verify --quiet refs/heads/"$BRANCH_NAME"; then
            echo "Local branch exists, switching to it"
            git checkout "$BRANCH_NAME"
          else
            echo "Local branch doesn't exist, creating from remote"
            git checkout -b "$BRANCH_NAME" origin/"$BRANCH_NAME"
          fi
          
          # Pull latest changes from remote to avoid conflicts
          git pull origin "$BRANCH_NAME"
          
        else
          echo "Remote branch $BRANCH_NAME doesn't exist, creating new branch"
          git checkout -b "$BRANCH_NAME"
        fi
        
    - name: Calculate block height
      run: |
        # Get current block height and timestamp
        CURRENT_BLOCK=$(curl -s -X 'GET' "${{ env.XION_TESTNET_API }}/blocks/latest" -H 'accept: application/json' | jq -r '.block.header.height')
        CURRENT_TIME=$(curl -s -X 'GET' "${{ env.XION_TESTNET_API }}/blocks/latest" -H 'accept: application/json' | jq -r '.block.header.time')
        
        echo "Current block: $CURRENT_BLOCK"
        echo "Current time: $CURRENT_TIME"
        
        # Get block from 10000 blocks ago
        OLD_BLOCK=$((CURRENT_BLOCK - 10000))
        OLD_BLOCK_INFO=$(curl -s -X 'GET' "${{ env.XION_TESTNET_API }}/blocks/$OLD_BLOCK" -H 'accept: application/json' | jq -r '.block.header.time')
        
        echo "Old block ($OLD_BLOCK) time: $OLD_BLOCK_INFO"
        
        # Calculate average block time (in seconds)
        CURRENT_TIMESTAMP=$(date -d "$CURRENT_TIME" +%s)
        OLD_TIMESTAMP=$(date -d "$OLD_BLOCK_INFO" +%s)
        TIME_DIFF=$((CURRENT_TIMESTAMP - OLD_TIMESTAMP))
        AVERAGE_BLOCK_TIME=$(echo "scale=2; $TIME_DIFF / 10000" | bc)
        
        echo "Average block time: ${AVERAGE_BLOCK_TIME} seconds"
        
        # Calculate blocks for 2 days (172800 seconds)
        BLOCKS_IN_2_DAYS=$(echo "scale=0; 172800 / $AVERAGE_BLOCK_TIME" | bc)
        
        # Calculate target block height (round to nearest 1000)
        TARGET_BLOCKS=$((BLOCKS_IN_2_DAYS + CURRENT_BLOCK))
        ROUNDED_BLOCKS=$(( (TARGET_BLOCKS + 500) / 1000 * 1000 ))
        
        echo "Blocks in 2 days: $BLOCKS_IN_2_DAYS"
        echo "Target block height: $ROUNDED_BLOCKS"
        
        # Set the calculated height as environment variable
        echo "CALCULATED_HEIGHT=$ROUNDED_BLOCKS" >> $GITHUB_ENV

    - name: Fetch release checksums
      run: |
        # Construct the checksums URL for the release
        CHECKSUMS_URL="https://github.com/burnt-labs/xion/releases/download/${{ env.RELEASE_TAG }}/xiond-${{ env.RELEASE_TAG }}-checksums.txt"
        echo "Fetching checksums from: $CHECKSUMS_URL"
        
        # Try to fetch the checksums file
        CHECKSUMS_RESPONSE=$(curl -s -w "%{http_code}" "$CHECKSUMS_URL" -o checksums_temp.txt)
        HTTP_CODE="${CHECKSUMS_RESPONSE: -3}"
        
        if [ "$HTTP_CODE" = "200" ]; then
          echo "‚úÖ Successfully fetched checksums for ${{ env.RELEASE_TAG }}"
          
          # Parse the checksums file and extract values
          CHECKS_FILE="checksums_temp.txt"
          
          # Extract checksums for different platforms
          DARWIN_AMD64_CHECKSUM=$(grep "darwin_amd64.tar.gz" "$CHECKS_FILE" | awk '{print $1}')
          DARWIN_ARM64_CHECKSUM=$(grep "darwin_arm64.tar.gz" "$CHECKS_FILE" | awk '{print $1}')
          LINUX_AMD64_CHECKSUM=$(grep "linux_amd64.tar.gz" "$CHECKS_FILE" | awk '{print $1}')
          LINUX_ARM64_CHECKSUM=$(grep "linux_arm64.tar.gz" "$CHECKS_FILE" | awk '{print $1}')
          
          # Set environment variables with real checksums
          echo "DARWIN_AMD64_CHECKSUM=$DARWIN_AMD64_CHECKSUM" >> $GITHUB_ENV
          echo "DARWIN_ARM64_CHECKSUM=$DARWIN_ARM64_CHECKSUM" >> $GITHUB_ENV
          echo "LINUX_AMD64_CHECKSUM=$LINUX_AMD64_CHECKSUM" >> $GITHUB_ENV
          echo "LINUX_ARM64_CHECKSUM=$LINUX_ARM64_CHECKSUM" >> $GITHUB_ENV
          
          echo "‚úÖ Using real checksums:"
          echo "  Darwin AMD64: $DARWIN_AMD64_CHECKSUM"
          echo "  Darwin ARM64: $DARWIN_ARM64_CHECKSUM"
          echo "  Linux AMD64: $LINUX_AMD64_CHECKSUM"
          echo "  Linux ARM64: $LINUX_ARM64_CHECKSUM"
          
        else
          echo "‚ö†Ô∏è  Checksums file not found for ${{ env.RELEASE_TAG }} (HTTP $HTTP_CODE)"
          if [ "$HTTP_CODE" = "404" ]; then
            echo "üìù This appears to be a future release - checksums will be available when the release is published"
          fi
          echo "üìù Using placeholder values for now"
          
          # Set environment variables with placeholder values
          echo "DARWIN_AMD64_CHECKSUM=${{ env.PLACEHOLDER_CHECKSUM_DARWIN_AMD64 }}" >> $GITHUB_ENV
          echo "DARWIN_ARM64_CHECKSUM=${{ env.PLACEHOLDER_CHECKSUM_DARWIN_ARM64 }}" >> $GITHUB_ENV
          echo "LINUX_AMD64_CHECKSUM=${{ env.PLACEHOLDER_CHECKSUM_LINUX_AMD64 }}" >> $GITHUB_ENV
          echo "LINUX_ARM64_CHECKSUM=${{ env.PLACEHOLDER_CHECKSUM_LINUX_ARM64 }}" >> $GITHUB_ENV
          
          echo "üìù Using placeholder checksums (will be updated when release is available)"
        fi
        
        # Clean up temporary file
        rm -f checksums_temp.txt
  
    - name: Get GitHub comparison data
      run: |
        # Extract version number from release tag
        CURRENT_VERSION="${{ env.RELEASE_TAG }}"
        # Extract major version number and calculate previous version
        CURRENT_MAJOR=$(echo "$CURRENT_VERSION" | sed 's/v\([0-9]*\)\.0\.0/\1/')
        PREVIOUS_MAJOR=$((CURRENT_MAJOR - 1))
        
        PREVIOUS_VERSION="v${PREVIOUS_MAJOR}.0.0"
        
        echo "Current version: $CURRENT_VERSION"
        echo "Previous version: $PREVIOUS_VERSION"
        
        # Check if current version (future release) exists in the repository
        CURRENT_TAG_EXISTS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          "https://api.github.com/repos/burnt-labs/xion/git/refs/tags/$CURRENT_VERSION" | \
          jq -r '.ref // "not_found"')
        
        if [[ "$CURRENT_TAG_EXISTS" == "not_found" ]]; then
          echo "‚ö†Ô∏è  Current version $CURRENT_VERSION doesn't exist yet (future release)"
          echo "üìù Creating placeholder comparison data for future release documentation"
          
          # Create placeholder comparison data for future release
          COMPARISON_DATA='{"total_commits": "TBD", "files": [], "commits": [], "ahead_by": "TBD", "message": "Future release - comparison will be available when release is published"}'
          COMMIT_COUNT="TBD"
          FILES_CHANGED="TBD"
          
          echo "-- Using placeholder data for future release --"
        else
          # Get GitHub comparison data for existing releases
          COMPARISON_URL="https://api.github.com/repos/burnt-labs/xion/compare/$PREVIOUS_VERSION...$CURRENT_VERSION"
          echo "Fetching comparison from: $COMPARISON_URL"
          
          # Fetch the comparison data
          COMPARISON_DATA=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" "$COMPARISON_URL")
          
          # Check if the API response contains an error
          ERROR_MESSAGE=$(echo "$COMPARISON_DATA" | jq -r '.message // empty')
          
          if [[ "$ERROR_MESSAGE" == "Not Found" ]]; then
            echo "‚ö†Ô∏è  Previous version $PREVIOUS_VERSION not found in GitHub"
            echo "üìù One of two versions doesn't exist"
            
            # Create empty comparison data
            COMPARISON_DATA='{"total_commits": 0, "files": [], "commits": []}'
            COMMIT_COUNT=0
            FILES_CHANGED=0
            
            echo "-- Using empty comparison data --"
          else
            echo "‚úÖ Successfully fetched comparison data"
            
            # Extract key information
            COMMIT_COUNT=$(echo "$COMPARISON_DATA" | jq -r '.total_commits // 0')
            FILES_CHANGED=$(echo "$COMPARISON_DATA" | jq -r '.files | length // 0')
          fi
        fi
        
        echo "Commits: $COMMIT_COUNT"
        echo "Files changed: $FILES_CHANGED"
        
        # Save comparison data to file for Claude API (even if placeholder)
        echo "$COMPARISON_DATA" > comparison_data.json
        
        # Set environment variables
        echo "PREVIOUS_VERSION=$PREVIOUS_VERSION" >> $GITHUB_ENV
        echo "COMMIT_COUNT=$COMMIT_COUNT" >> $GITHUB_ENV
        echo "FILES_CHANGED=$FILES_CHANGED" >> $GITHUB_ENV
        
    - name: Generate release notes with Claude API
      run: |
        pwd
        ls -la
        ls -la .github/workflows
        # Load and prepare the prompt from external file
        PROMPT=$(cat .github/workflows/prompts/claude-api-prompt.md)
        
        # Replace placeholders with environment variables
        PROMPT="${PROMPT//\{\{RELEASE_TAG\}\}/${{ env.RELEASE_TAG }}}"
        PROMPT="${PROMPT//\{\{CALCULATED_HEIGHT\}\}/${{ env.CALCULATED_HEIGHT }}}"
        PROMPT="${PROMPT//\{\{PREVIOUS_VERSION\}\}/${{ env.PREVIOUS_VERSION }}}"
        
        echo "Loaded Claude API prompt from external file"
        
        # Call Claude API
        CLAUDE_RESPONSE=$(curl -s -X POST "https://api.anthropic.com/v1/messages" \
          -H "Content-Type: application/json" \
          -H "x-api-key: ${{ secrets.BURNT_CLAUDE_API_KEY }}" \
          -H "anthropic-version: 2023-06-01" \
          -d '{
            "model": "claude-3-sonnet-20240229",
            "max_tokens": 4000,
            "messages": [
              {
                "role": "user",
                "content": "'"$PROMPT"'\n\nGitHub Comparison Data:\n'"$(cat comparison_data.json | jq -c .)"'"
              }
            ]
          }')
        
        # Extract the response content
        RELEASE_NOTES_CONTENT=$(echo "$CLAUDE_RESPONSE" | jq -r '.content[0].text')
        
        # Save the generated release notes
        echo "$RELEASE_NOTES_CONTENT" > generated_release_notes.md
        
        echo "Generated release notes saved to generated_release_notes.md"
         
    - name: Use fallback template if Claude API fails
      run: |
        # Use the generated release notes if available, otherwise use template
        if [ -f "generated_release_notes.md" ]; then
          echo "Using AI-generated release notes"
          cp generated_release_notes.md release_notes_template.md
        else
          echo "Using fallback template (Claude API may have failed)"
          
          # Load fallback template from external file
          FALLBACK_TEMPLATE=$(cat .github/workflows/prompts/fallback-template.md)
          
          # Replace placeholders with environment variables
          FALLBACK_TEMPLATE="${FALLBACK_TEMPLATE//\{\{RELEASE_TAG\}\}/${{ env.RELEASE_TAG }}}"
          FALLBACK_TEMPLATE="${FALLBACK_TEMPLATE//\{\{CALCULATED_HEIGHT\}\}/${{ env.CALCULATED_HEIGHT }}}"
          FALLBACK_TEMPLATE="${FALLBACK_TEMPLATE//\{\{PREVIOUS_VERSION\}\}/${{ env.PREVIOUS_VERSION }}}"
          
          # Save the processed template
          echo "$FALLBACK_TEMPLATE" > release_notes_template.md
          echo "Created fallback template from external file"
        fi
        
    - name: Run release files creation script
      run: |
        ./scripts/create-release-pr.sh "${{ env.CALCULATED_HEIGHT }}" "${{ env.DEPOSIT }}" "${{ env.EXPEDITED }}" "${{ env.RELEASE_TAG }}"
        
    - name: debug - Echo release files
      run: |
        echo "-> Proposal file"
        cat proposals/038-upgrade-v22.json
        
        echo "-> Release file"
        cat releases/v22.json
        
        echo "-> Release notes file"
        cat release_notes/v22.md
        
    - name: Set environment variables from script output
      run: |
        # Find the actual files that were created (after script runs)
        VERSION_NUM=$(echo "${{ env.RELEASE_TAG }}" | sed 's/v\([0-9]*\)\.0\.0/\1/')
        VERSION="v${VERSION_NUM}"
        
        # These will be set after the script creates the files
        echo "PROPOSAL_FILE=proposals/038-upgrade-$VERSION.json" >> $GITHUB_ENV
        echo "RELEASE_FILE=releases/$VERSION.json" >> $GITHUB_ENV
        echo "RELEASE_NOTES_FILE=release_notes/$VERSION.md" >> $GITHUB_ENV
        
    - name: Commit and push changes
      run: |
        # Check if any of the created files have changes
        CHANGES_DETECTED=false
        
        # Check each file individually and add only if changed
        for file in "${{ env.PROPOSAL_FILE }}" "${{ env.RELEASE_FILE }}" "${{ env.RELEASE_NOTES_FILE }}"; do
          if [ -f "$file" ]; then
            # Check if file has changes (new file or modified)
            if git diff --quiet "$file" 2>/dev/null; then
              echo "‚ÑπÔ∏è  No changes in $file"
            else
              echo "üìù Changes detected in $file"
              git add "$file"
              CHANGES_DETECTED=true
            fi
          else
            echo "‚ö†Ô∏è  File $file does not exist"
          fi
        done
        
        # Commit and push only if we have changes in the created files
        if [ "$CHANGES_DETECTED" = true ]; then
          git commit -m "Added release ${{ env.VERSION }}
          
          - Created ${{ env.PROPOSAL_FILE }}
          - Created ${{ env.RELEASE_FILE }}
          - Created ${{ env.RELEASE_NOTES_FILE }}
          
          Release Tag: ${{ env.RELEASE_TAG }}
          Upgrade height: ${{ env.CALCULATED_HEIGHT }} (calculated: 2 days from current block)
          Deposit: ${{ env.DEPOSIT }}
          Expedited: ${{ env.EXPEDITED }}"
          
          # Push the feature branch
          git push origin "${{ env.BRANCH_NAME }}"
          echo "‚úÖ Changes committed and pushed"
        else
          echo "‚ÑπÔ∏è  No changes detected in created files - skipping commit and push"
        fi
        
    - name: Create Pull Request
      uses: peter-evans/create-pull-request@v5 # https://github.com/peter-evans/create-pull-request?tab=readme-ov-file
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        branch: ${{ env.BRANCH_NAME }}  # Source: release/vXX.0.0
        base: feat/do-85-generate-upgrade-proposals-n-release-binaries   # TODO Target: main
        title: "Added release ${{ env.VERSION }}"
        reviewers: wehappyfew,2xburnt
        body: |
          ## Upgrade to release ${{ env.VERSION }}
          
          This PR upgrades to release ${{ env.VERSION }}.
          
          ### Files created/modified:
          - `${{ env.PROPOSAL_FILE }}`
          - `${{ env.RELEASE_FILE }}`
          - `${{ env.RELEASE_NOTES_FILE }}`
          
          ### Configuration:
          - **Release Tag**: ${{ env.RELEASE_TAG }}
          - **Upgrade Height**: ${{ env.CALCULATED_HEIGHT }} (calculated: 2 days from current block)
          - **Deposit**: ${{ env.DEPOSIT }}
          - **Expedited**: ${{ env.EXPEDITED }}
        delete-branch: false
